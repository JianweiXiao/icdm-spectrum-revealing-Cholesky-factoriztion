! SPECTRUM REVEALING CHOLEKSY FACTORIZATION
! STEP 1: USE RANDOM PROJECTION PIVOTING STRATEGY TO GET A TRUNCATED R CHOLEKSY FACTORIZATION OF A
! STEP 2: DO SWAPS TO GET A SPECTRUM REVEALING CHOLESKY FACTORIZATION
!
!   INPUTS:     A  - POSITIVE SEMIDEFINITE MATRIX
!               N  - SIZE OF MATRIX A 
!               W  - RANDOM PROJECTION MATRIX, DIMENSION IS NP BY N
!               BLOCKSIZE - BLOCK SIZE
!                    DOES NOT NEED TO DIVIDE M OR N
!               NP - OVERSAMPLING PARAMETER
!                    NP >= NB
!               R  - EXPECTED RANK
!               G  - PARAMETER, SHOULD BE LARGER THAN 1
!
!
!   OUTPUTS:    L FACTOR = (TRIL(A))(1:N,1:N) (R+1:N COLUMNS WILL BE ZERO)
!               IPIV - PIVOTS
!

SUBROUTINE SRCH(A, N, W, BLOCKSIZE, NP, R, IPIV, G)

	IMPLICIT NONE 

	INTEGER, INTENT(IN) :: N, NP, BLOCKSIZE
	INTEGER, INTENT(INOUT) :: R
	REAL*8, INTENT(IN) :: G
	REAL*8, INTENT(INOUT), DIMENSION(N,N) :: A 
	REAL*8, INTENT(INOUT), DIMENSION(NP,N) :: W
	INTEGER, INTENT(OUT), DIMENSION(N) :: IPIV

	INTEGER :: NB, ICOL, I, J, INFO, RANK, ITEMP, IN
	INTEGER, DIMENSION(N) :: IPIV_B
	REAL*8, DIMENSION(BLOCKSIZE) :: TAU_B
	INTEGER, ALLOCATABLE, DIMENSION(:) :: PIV
	REAL*8, DIMENSION(NP,N) :: B, B_TEMP
	REAL*8, DIMENSION(N,NP) :: BTEMP 
	REAL*8, DIMENSION(NP,N) :: BUPDATE
	REAL*8, ALLOCATABLE, DIMENSION(:) :: WORK
	REAL*8 :: ONE, ZERO, NEGATIVE_ONE
	! STORE DIAGONAL ELEMENTS OF TRAILING MATRIX
	REAL*8, DIMENSION(N) :: DIAGONAL
	! BIGGEST ELEMENT ON THE DIAGONAL OF TRAILING MATRIX 
	REAL*8 :: ALPHA 
	! USED IN THE SECOND PART OF STEP2. CHECK THE STOPPING CONDITION OF RANK REVEALING CHOLESKY
	REAL*8, ALLOCATABLE, DIMENSION(:,:) :: LTEMP 
	PARAMETER( ONE = 1.0D+0, ZERO = 0.0D+0, NEGATIVE_ONE = -1.0D+0 )
	REAL*8 :: SQRT, DNRM2
	! STORE THE COLUMN NORMS OF LTEMP. 
	REAL*8, ALLOCATABLE, DIMENSION(:) :: LTEMP_NORM 
	! STORE THE INDEX OF THE COLUMN WE WANT TO SWAP OUT THE L FACTOR WE ALREADY COMPUTED
	INTEGER :: INDEX 
	! STORE THE NORM OF THE COLUMN WITH THE LARGEST NORM
	REAL*8 :: MAX_NORM 
	! 2 BY 2 MATRIX IN DOING GIVENS ROTATION. LAPACK SUBROUTINE DLAROT MAY PROBABLY WORK BETTER
	REAL*8, DIMENSION(2,2) :: GIVENS 
	! USED IN INTERCHANGE KTH COLUMN(ROW) AND K+1TH COLUMN(ROW) IN THE LAST STEP OF DOING SWAPS
	REAL*8, ALLOCATABLE, DIMENSION(:) :: VECTOR 
	REAL*8 :: TEMP_REAL
	INTEGER :: COUNTER
	REAL*8, DIMENSION(N) :: A_DIAGONAL
	REAL*8, DIMENSION(N,N) :: A_ORIGINAL
	REAL*8, DIMENSION(:,:), ALLOCATABLE :: OMEGA_L, COMPRESSION_L
	REAL*8 :: DA, DB, C, S
	INTEGER :: D_L
	INTEGER :: ISEED(4)
	REAL*8, DIMENSION(N,1) :: HELP_DROT
	HELP_DROT = ZERO

	ISEED(1) = 23
	ISEED(2) = 45
	ISEED(3) = 67
	ISEED(4) = 78

	A_ORIGINAL = A
	DIAGONAL = 0.0_8
	DO I = 1,N
		IPIV(I) = I
	END DO
	NB = BLOCKSIZE
	ALLOCATE(WORK(10*N))

	DO I = 1,N
		A_DIAGONAL(I) = A(I,I)
	END DO

	IF (NP < NB) THEN
		WRITE(*,*) 'INSUFFICIENT RANDOM SAMPLING'
	END IF

	R = MIN(N,R)
	IF (R < 1) THEN
		WRITE(*,*) 'EXPECTED RANK TOO SMALL'
	END IF 

	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	! FIRST STEP: USE RANDOM PROJECTION PIVOTING STRATEGY TO GET A TRUNCATED R CHOLEKSY FACTORIZATION OF A !
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	! COMPUTE RANDOM PROJECTION B = W * A
	CALL DGEMM('N','N',NP,N,N,ONE,W,NP,A,N,ZERO,B,NP)

	! LOOP THROUGH LEADING COLUMNS
	DO ICOL = 1, R, NB
		NB = MIN(NB, R-ICOL+1)
		! INITIALIZE IPIV_B 
		IPIV_B = 0

		! COPY B(1:NP, ICOL:N) TO B_TEMP(1:NP, ICOL:N)
		CALL DLACPY( 'ALL', NP, N-ICOL+1, B(1,ICOL), NP, B_TEMP(1,ICOL), NP )

		! DO PARTIAL QRCP ON B TO FIND NB PIVOTS
		CALL PARTIAL_DGEQPF(NB, NP, N-ICOL+1, B_TEMP(1, ICOL), NP, IPIV_B(ICOL), TAU_B, WORK)

		! APPLY THESE PIVOTS ON A
		DO I = ICOL, N
			IPIV_B( I ) = -IPIV_B( I )
		END DO

		DO I = ICOL, N
			IF( IPIV_B( I ).GT.0 ) THEN
				GO TO 30
			ELSE
			END IF

			J = I
			IPIV_B( J ) = -IPIV_B( J )
			IN = IPIV_B( J ) + ICOL - 1

			40 CONTINUE
			IF( IPIV_B( IN ).GT.0 ) THEN
				GO TO 30
			ELSE
			END IF

			IF (J .NE. IN) THEN
				CALL DSWAP( N-ICOL+1, A(ICOL, J), 1, A(ICOL, IN), 1 )
				CALL DSWAP( N, A(J, 1), N, A(IN, 1), N)
				CALL DSWAP( NP, W(1, J), 1, W(1, IN), 1)
				CALL DSWAP( NP, B(1, J), 1, B(1, IN), 1)

				ITEMP = IPIV(J)
				IPIV(J) = IPIV(IN)
				IPIV(IN) = ITEMP
			ELSE
			END IF

			IPIV_B( IN ) = -IPIV_B( IN )
			J = IN
			IN = IPIV_B( IN ) + ICOL - 1
			GO TO 40
			30 CONTINUE
		END DO

		! A(ICOL:N,ICOL:ICOL+NB-1) = A(ICOL:N, ICOL:ICOL+NB-1) - MATMUL(A(ICOL:N, 1:ICOL-1), TRANSPOSE(A(ICOL:ICOL+NB-1, 1:ICOL-1)))
		CALL DGEMM('N','T',N-ICOL+1,NB,ICOL-1,-ONE,A(ICOL,1),N,A(ICOL,1),N,ONE,A(ICOL,ICOL),N) 
		CALL DPOTF2('L', NB, A(ICOL,ICOL), N, INFO)

		! SET STRICTLY UPPER PART OF A(ICOL+NB:N,ICOL:ICOL-1+NB) TO BE ZERO
		CALL DLASET( 'U', NB-1, NB-1, 0.0_8, 0.0_8, A(ICOL,ICOL+1), N )
		! ORIGINAL CODE: A(ICOL+NB:N,ICOL:ICOL-1+NB) = A(ICOL+NB:N,ICOL:ICOL-1+NB) / TRANSPOSE(LBLOCK)
		CALL DTRSM('R', 'L', 'T', 'N', N-ICOL-NB+1, NB, ONE, A(ICOL,ICOL), N, A(ICOL+NB,ICOL), N)

		IF (ICOL+NB-1 < R ) THEN
			!   B(1:NP,ICOL+NB:N) = B(1:NP,ICOL+NB:N) - MATMUL(W(1:NP,ICOL:N), A(ICOL:N,ICOL:ICOL+NB-1)) * TRANSPOSE(A(ICOL+NB:N, ICOL:ICOL+NB-1))
			CALL DGEMM('N', 'N', NP, NB, N-ICOL+1, 1.0_8, W(1,NP), NP, A(ICOL,ICOL), N, 0.0_8, BUPDATE, NP)
			CALL DGEMM('N', 'T', NP, N-ICOL-NB+1, NB, -1.0_8, BUPDATE, NP, A(ICOL+NB, ICOL), N, 1.0_8, B, NP)
		END IF
	END DO
	DEALLOCATE(WORK)

	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	! SECOND STEP: DO SWAPS TO GET A SPECTRUM REVEALING CHOLESKY FACTORIZATION !
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	COUNTER = 0
	DO I = 1,R
		A(I,I+1:N) = ZERO
	END DO
	D_L = BLOCKSIZE
	ALLOCATE(LTEMP(R+1,R+1), LTEMP_NORM(R), VECTOR(N-R+1))
	ALLOCATE(OMEGA_L(D_L,R+1), COMPRESSION_L(D_L,R+1))
	CALL DLARNV(3, ISEED, D_L*(R+1), OMEGA_L)
	! LATER INSTEAD OF COMPUTING HAT{L}^{-1}, COMPUTE OMEGA_L * HAT{L}^{-1}, SOLVING A TRIANGULAR SYSTEM
	! IT'S A D_L * (R+1) AND (R+1) * (R+1) MULTIPLICATION
	DO WHILE (COUNTER .LE. 20)

		! INITIALIZE DIAGONAL
		DIAGONAL(R+1:N) = A_DIAGONAL(IPIV(R+1:N))

		! COMPUTE DIAGONAL
		DO I = R+1,N
			DO J = 1,R
				DIAGONAL(I) = DIAGONAL(I) - (A(I,J) * A(I,J)) 
			END DO
		END DO

		I = MAXLOC(DIAGONAL(R+1:N),1)
		ALPHA = DIAGONAL(R+I)

		! SWAP R+I AND R+1 COLUMN AND ROW. UPDATE P.
		CALL DSWAP(N-R, A(R+1,R+1), 1, A(R+1,R+I), 1)
		CALL DSWAP(N, A(R+1,1), N, A(R+I,1), N)
		ITEMP = IPIV(R+I)
		IPIV(R+I) = IPIV(R+1)
		IPIV(R+1) = ITEMP

		! UPDATE PIVOTED COLUMN, HELP_DROT(R+1:N,1) = A(R+1:N,R+1) - A(R+1:N,1:R) * A(R+1,1:R)'
		! THEN SCALE HELP_DROT(R+1:N,1) BY SQRT(ALPHA), I.E., DO ONE MOE STEP CHOLESKY
		CALL DGEMM('N', 'T', N-R, 1, R, ONE, A(R+1,1), N, A(R+1,1), N, ZERO, HELP_DROT(R+1,1), N)
		HELP_DROT(R+1:N,1) = A(R+1:N,R+1) - HELP_DROT(R+1:N,1)
		CALL DSCAL(N-R, SQRT(ALPHA), HELP_DROT(R+1,1), 1)

		LTEMP(1:R+1,1:R) = A(1:R+1,1:R)
		LTEMP(1:R,R+1) = ZERO
		LTEMP(R+1,R+1) = SQRT(ALPHA)
		COMPRESSION_L = OMEGA_L

		! COMPUTE COMPRESSION_L = COMPRESSION_L * INV(LTEMP)
		CALL DTRSM('R', 'L', 'N', 'N', D_L, R+1, ONE, LTEMP, R+1, COMPRESSION_L, D_L)

		DO I = 1,R
			LTEMP_NORM(I) = DNRM2(D_L, COMPRESSION_L(1,I), 1)
		END DO

		INDEX = MAXLOC(LTEMP_NORM,1)
		IF (SQRT(G * D_L) .GE. SQRT(ALPHA) * LTEMP_NORM(INDEX)) THEN
			GO TO 10
		ELSE
		END IF

		COUNTER = COUNTER + 1

		! FIRST WE DO ROUND-ROBIN ROTATION.
		ALLOCATE(PIV(R-INDEX+1))
		DO I = 1,R-INDEX
			PIV(I) = I + 1
		END DO
		PIV(R-INDEX+1) = 1

		CALL DLAPMR(.TRUE., R-INDEX+1, R, A(INDEX,1), N, PIV)

		! THEN WE NEED TO USE GIVENS ROTATION TO MAKE L11 LOWER TRIANGULAR AGAIN
		! NOTICE: L21 WILL BE ALSO CHANGED BY THE GIVENS ROTATION
		! IN THIS STEP, THE SCHUR COMPLEMENT S WON'T CHANGE

		DO I = INDEX, R-1
			DA = A(I,I)
			DB = A(I,I+1)
			CALL DROTG(DA, DB, C, S)
			CALL DROT(N-I+1, A(I,I), 1, A(I,I+1), 1, C, S)
		END DO

		! UPDATE PIVOTING VECTOR P
		DO I = 1,R-INDEX
			PIV(I) = IPIV(INDEX+I)
		END DO
		PIV(R-INDEX+1) = IPIV(INDEX)
		IPIV(INDEX:R) = PIV(1:R-INDEX+1)

		! INTERCHANGE RTH ROW AND R+1TH ROW
		! UPDATE IPIV
		CALL DSWAP(R-1, A(R,1), N, A(R+1,1), N)
		ITEMP = IPIV(R)
		IPIV(R) = IPIV(R+1)
		IPIV(R+1) = ITEMP

		VECTOR = A_ORIGINAL(IPIV(R:N),IPIV(R))
		CALL DGEMM('N', 'T', N-R+1, 1, R-1, -ONE, A(R,1), N, A(R,1), N, ONE, VECTOR, N-R+1)
		CALL DRSCL(N-R+1, SQRT(VECTOR(1)), VECTOR, 1)
		A(R:N,R) = VECTOR

		DEALLOCATE(PIV)
	END DO

	10 DEALLOCATE(LTEMP, LTEMP_NORM, VECTOR)
	! WRITE(*,*) 'G VALUE IS', G
	! WRITE (*,*) 'NUMBER OF ITERAITON IS', COUNTER
END SUBROUTINE SRCH
